# Restore a backup already stored on the targetted server
name: Restore Local Backup

run-name: Restore ${{ inputs.environment }} - ${{ inputs.backup_timestamp && format(' ({0})', inputs.backup_timestamp) || ' (latest)' }}

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to restore"
        required: true
        type: environment
      backup_timestamp:
        description: "Backup timestamp (YYYYMMDD-HHMMSS) or leave empty for latest"
        required: false
        type: string

jobs:
  restore:
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment }}
    
    steps:
      - name: Restore backup on server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.SERVER_HOST }}
          username: ${{ vars.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd ${{ vars.DEPLOY_PATH }}
            
            # Determine which backup to restore
            if [ -n "${{ inputs.backup_timestamp }}" ]; then
              TIMESTAMP="${{ inputs.backup_timestamp }}"
            else
              # Get timestamp from latest database backup
              LATEST_DB=$(ls -t ./backups/db-backup-*.sql 2>/dev/null | head -1)
              if [ -z "$LATEST_DB" ]; then
                echo "[ERROR] No backups found in ./backups/"
                ls -lh ./backups/ || echo "Backups directory does not exist"
                exit 1
              fi
              TIMESTAMP=$(basename "$LATEST_DB" | sed 's/db-backup-\(.*\)\.sql/\1/')
            fi
            
            DB_BACKUP="./backups/db-backup-${TIMESTAMP}.sql"
            FILES_BACKUP="./backups/files-backup-${TIMESTAMP}.tar.gz"
            UPLOADS_BACKUP="./backups/uploads-backup-${TIMESTAMP}.tar.gz"
            
            echo "[INFO] Restoring backup with timestamp: $TIMESTAMP"
            echo "[INFO] Database backup: $DB_BACKUP"
            echo "[INFO] Files backup: $FILES_BACKUP"
            echo "[INFO] Uploads backup: $UPLOADS_BACKUP"
            
            # Verify all backup files exist
            if [ ! -f "$DB_BACKUP" ]; then
              echo "[ERROR] Database backup not found: $DB_BACKUP"
              exit 1
            fi
            
            if [ ! -f "$FILES_BACKUP" ]; then
              echo "[ERROR] Files backup not found: $FILES_BACKUP"
              exit 1
            fi
            
            if [ ! -f "$UPLOADS_BACKUP" ]; then
              echo "[ERROR] Uploads backup not found: $UPLOADS_BACKUP"
              exit 1
            fi
            
            echo "[INFO] All backup files verified"
            
            # Stop services
            echo "[INFO] Stopping services..."
            docker compose down
            
            # Restore project files
            echo "[INFO] Restoring project files..."
            tar -xzf "$FILES_BACKUP"
            echo "[INFO] Project files restored"
            
            # Start postgres only
            echo "[INFO] Starting postgres..."
            docker compose up -d postgres
            sleep 10
            
            # Wait for postgres to be ready
            echo "[INFO] Waiting for postgres to be ready..."
            for i in {1..30}; do
              if docker compose exec -T postgres pg_isready -U "${{ vars.DB_USER }}" > /dev/null 2>&1; then
                echo "[INFO] Postgres is ready"
                break
              fi
              echo "[INFO] Waiting for postgres... ($i/30)"
              sleep 2
            done
            
            # Restore database
            echo "[INFO] Restoring database..."
            echo "[INFO] Terminating existing connections..."
            docker compose exec -T postgres psql -U "${{ vars.DB_USER }}" postgres -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '${{ vars.DB_DATABASE }}' AND pid != pg_backend_pid();" || true
            
            echo "[INFO] Dropping existing database..."
            docker compose exec -T postgres dropdb -U "${{ vars.DB_USER }}" --if-exists "${{ vars.DB_DATABASE }}"
            
            echo "[INFO] Creating database..."
            docker compose exec -T postgres createdb -U "${{ vars.DB_USER }}" "${{ vars.DB_DATABASE }}"
            
            echo "[INFO] Importing database backup..."
            docker compose exec -T postgres psql -U "${{ vars.DB_USER }}" "${{ vars.DB_DATABASE }}" < "$DB_BACKUP"
            echo "[INFO] Database restored successfully"
            
            # Restore uploads to Docker volume
            echo "[INFO] Restoring uploads to Docker volume..."
            docker run --rm \
              -v ${COMPOSE_PROJECT_NAME:-nuxt-directus-docker-template}_directus_uploads:/data \
              -v $(pwd)/backups:/backup \
              alpine sh -c "rm -rf /data/* && tar xzf /backup/uploads-backup-${TIMESTAMP}.tar.gz -C /data"
            echo "[INFO] Uploads restored successfully"
            
            # Rebuild and start all services
            echo "[INFO] Rebuilding and starting all services..."
            docker compose up --build -d
            
            # Wait for services to be ready
            echo "[INFO] Waiting for services to be ready..."
            sleep 10
            
            # Check Directus health
            for i in {1..20}; do
              if docker compose exec -T directus wget --no-verbose --tries=1 -O- http://127.0.0.1:8055/server/health 2>/dev/null | grep -q '"status":"ok"'; then
                echo "[INFO] Directus is ready!"
                break
              fi
              echo "[INFO] Waiting for Directus... ($i/20)"
              sleep 5
            done
            
            # Show final status
            echo "[INFO] Restore complete. Service status:"
            docker compose ps
            echo "[INFO] Backup timestamp: $TIMESTAMP"